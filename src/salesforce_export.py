"""
Module d'export et transformation des donn√©es pour Salesforce
"""

import pandas as pd
import logging
from typing import Dict, Any, Tuple, Optional

logger = logging.getLogger(__name__)

class SalesforceExporter:
    """Exporteur pour transformer les donn√©es INSEE en format Salesforce"""
    
    def __init__(self):
        """Initialise l'exporteur"""
        self.size_mapping = {
            'MICRO': {'range': (0, 19), 'default': 10},
            'PME': {'range': (20, 249), 'default': 135}, 
            'ETI': {'range': (250, 4999), 'default': 2625},
            'GE': {'range': (5000, float('inf')), 'default': 10000}
        }
    
    def transform_for_salesforce(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Transforme les donn√©es INSEE en format compatible Salesforce
        
        Args:
            df: DataFrame avec donn√©es INSEE brutes
            
        Returns:
            DataFrame transform√© pour Salesforce
        """
        logger.info(f"üìä Traitement des donn√©es pour Salesforce...")
        logger.info(f"üìÑ Fichier charg√©: {len(df)} entreprises")
        
        df_salesforce = df.copy()
        
        logger.info(f"üîÑ Conversion des tranches d'effectifs...")
        
        # Conversion des effectifs en format num√©rique Salesforce
        df_salesforce['Effectifs_Salesforce'] = df_salesforce.apply(
            self._convert_effectifs_to_salesforce, axis=1
        )
        
        # D√©termination du niveau de confiance
        df_salesforce['Confiance_Donnee'] = df_salesforce.apply(
            self._determine_confidence_level, axis=1
        )
        
        # D√©termination du statut de r√©vision intelligent
        df_salesforce['Statut_Revision'] = df_salesforce.apply(
            self._determine_revision_status, axis=1
        )
        
        # G√©n√©ration des notes de r√©vision
        df_salesforce['Notes_Revision'] = df_salesforce.apply(
            self._generate_revision_notes, axis=1
        )
        
        # Correction automatique des effectifs manquants
        df_salesforce = self._fix_missing_effectifs(df_salesforce)
        
        # R√©organisation des colonnes dans l'ordre optimal
        df_salesforce = self._reorder_columns(df_salesforce)
        
        # Statistiques finales
        self._log_salesforce_stats(df_salesforce)

        return df_salesforce
    
    def _reorder_columns(self, df: pd.DataFrame) -> pd.DataFrame:
        """R√©organise les colonnes dans un ordre logique et lisible"""
        
        # Ordre souhait√© : infos de base, statuts, effectifs, donn√©es INSEE d√©taill√©es
        ordered_columns = [
            # Informations de base
            'Organisation_Original',
            'Taille_Original', 
            'Categorie_Entreprise_INSEE',
            'Statut_Recherche',
            
            # Statuts de r√©vision
            'Statut_Revision',
            'Notes_Revision',
            
            # Effectifs (du plus g√©n√©ral au plus sp√©cifique)
            'Effectifs_Description',
            'Effectifs_Numeric',
            'Effectifs_Salesforce',
            
            # Identifiants INSEE
            'SIREN',
            'SIRET',
            'Confiance_Donnee',
            
            # Donn√©es INSEE d√©taill√©es
            'Denomination_INSEE',
            'Date_Creation',
            'Activite_Principale',
            'Etat_Administratif',
            'Etablissement_Siege',
            'Nombre_Etablissements',
            'tranche_effectifs_unite_legale'
        ]
        
        # Garder seulement les colonnes qui existent
        available_columns = [col for col in ordered_columns if col in df.columns]
        
        # Ajouter les colonnes manquantes √† la fin (au cas o√π)
        remaining_columns = [col for col in df.columns if col not in available_columns]
        final_column_order = available_columns + remaining_columns
        
        return df[final_column_order]
    
    def _convert_effectifs_to_salesforce(self, row: pd.Series) -> float:
        """Convertit les tranches d'effectifs en valeurs num√©riques"""
        if pd.notna(row.get('Effectifs_Numeric')):
            return float(row['Effectifs_Numeric'])
        return None
    
    def _determine_confidence_level(self, row: pd.Series) -> str:
        """D√©termine le niveau de confiance des donn√©es"""
        if row.get('Statut_Recherche') == 'Non trouv√©':
            return 'none'
        
        # Si trouv√© dans l'API INSEE ‚Üí confiance √©lev√©e
        if row.get('Statut_Recherche') == 'Trouv√©':
            # Donn√©es directes de l'API INSEE = haute confiance
            if not pd.isna(row.get('Effectifs_Numeric')):
                return 'high'
            else:
                return 'medium'  # Trouv√© mais effectifs manquants
        
        # Si pas trouv√© mais effectifs estim√©s
        if not pd.isna(row.get('Effectifs_Numeric')):
            return 'medium'  # Estimation coh√©rente
        else:
            return 'low'  # Pas de donn√©es fiables
    
    def _determine_revision_status(self, row: pd.Series) -> str:
        """D√©termine le statut de r√©vision intelligent"""
        if row.get('Statut_Recherche') == 'Non trouv√©':
            return 'NOT_FOUND'
        
        # V√©rification coh√©rence avec taille originale
        coherence = self._check_size_coherence(row)
        confiance = row.get('Confiance_Donnee', 'low')
        
        # Si confiance √©lev√©e et coh√©rent ‚Üí CONFIRM√â
        if confiance == 'high' and coherence == 'coherent':
            return 'CONFIRMED'
        
        # Si confiance moyenne et coh√©rent ‚Üí CONFIRM√â aussi  
        if confiance == 'medium' and coherence == 'coherent':
            return 'CONFIRMED'
        
        # Si incoh√©rent ‚Üí conflit √† r√©viser
        if coherence == 'incoherent':
            return 'CONFLICT_TO_REVIEW'
        
        # Si confiance faible ‚Üí toujours √† r√©viser
        if confiance == 'low':
            return 'TO_REVIEW'
        
        # Cas par d√©faut
        return 'TO_REVIEW'
    
    def _check_size_coherence(self, row: pd.Series) -> str:
        """V√©rifie la coh√©rence entre taille originale et classification INSEE officielle"""
        taille_original = row.get('Taille_Original', '')
        categorie_insee = row.get('Categorie_Entreprise_INSEE', '')
        
        if not categorie_insee or pd.isna(categorie_insee):
            return 'unknown'
        
        # Normalisation des tailles pour comparaison
        taille_original_clean = str(taille_original).strip().upper()
        categorie_insee_clean = str(categorie_insee).strip().upper()
        
        # Correspondance directe
        if taille_original_clean == categorie_insee_clean:
            return 'coherent'
        
        # Cas sp√©ciaux acceptables
        special_cases = {
            'GRANDE ENTREPRISE': 'GE',
            'PETITE ENTREPRISE': 'PME',
            'PETITES ET MOYENNES ENTREPRISES': 'PME',
            'ENTREPRISE DE TAILLE INTERM√âDIAIRE': 'ETI',
            'MICRO ENTREPRISE': 'MICRO'
        }
        
        taille_normalized = special_cases.get(taille_original_clean, taille_original_clean)
        if taille_normalized == categorie_insee_clean:
            return 'coherent'
        
        # Si diff√©rent, c'est incoh√©rent (mais pas forc√©ment une erreur)
        if taille_original_clean in ['NON SP√âCIFI√â', '', 'UNKNOWN', 'N/A']:
            return 'unknown'
        else:
            return 'incoherent'
    
    def _generate_revision_notes(self, row: pd.Series) -> str:
        """G√©n√®re des notes explicatives pour la r√©vision"""
        statut = row.get('Statut_Revision', '')
        effectifs_desc = row.get('Effectifs_Description', '')
        taille_original = row.get('Taille_Original', '')
        categorie_insee = row.get('Categorie_Entreprise_INSEE', '')
        effectifs = row.get('Effectifs_Numeric', 0)
        
        if statut == 'CONFIRMED':
            return f"‚úÖ Classification coh√©rente: {taille_original} = {categorie_insee} INSEE"
        elif statut == 'CONFLICT_TO_REVIEW':
            return f"‚ö†Ô∏è Classification divergente: {taille_original} d√©clar√© vs {categorie_insee} INSEE (effectifs: {effectifs})"
        elif statut == 'TO_REVIEW':
            if effectifs:
                return f"üìä Faible confiance ou grande tranche - {effectifs_desc} - V√©rifier"
            else:
                return f"üìä Donn√©es estim√©es selon {taille_original} - V√©rifier"
        elif statut == 'NOT_FOUND':
            return f"‚ùå Entreprise non trouv√©e dans base Sirene"
        else:
            return f"üìã √Ä r√©viser - {effectifs_desc}"
    
    def _fix_missing_effectifs(self, df: pd.DataFrame) -> pd.DataFrame:
        """Corrige les effectifs manquants selon la taille d'entreprise"""
        logger.info(f"\nüîß Correction automatique des effectifs manquants...")
        
        # Identifier les lignes o√π Effectifs_Numeric est manquant (vraiment manquant)
        missing_mask = df['Effectifs_Numeric'].isna()
        missing_count = missing_mask.sum()
        
        logger.info(f"üîç Effectifs manquants: {missing_count} ({missing_count/len(df)*100:.1f}%)")
        
        if missing_count == 0:
            logger.info("‚úÖ Aucun effectif manquant √† corriger")
            return df
        
        # Statistiques par taille avant correction
        logger.info(f"üìà R√âPARTITION DES MANQUANTS PAR TAILLE:")
        missing_by_taille = df[missing_mask]['Taille_Original'].value_counts()
        for taille, count in missing_by_taille.items():
            logger.info(f"   {taille}: {count} entreprises")
        
        corrections = 0
        df_copy = df.copy()
        
        for idx, row in df_copy[missing_mask].iterrows():
            taille = row['Taille_Original']
            # Utiliser les moyennes configur√©es pour Effectifs_Salesforce SEULEMENT
            effectifs_num, confiance = self._get_mean_effectifs_by_taille(taille)
            
            if effectifs_num is not None:
                # Mettre √† jour SEULEMENT Effectifs_Salesforce et confiance
                # NE PAS toucher Effectifs_Description (garde None = tranche officielle manquante)
                df_copy.at[idx, 'Effectifs_Salesforce'] = effectifs_num
                df_copy.at[idx, 'Confiance_Donnee'] = confiance
                
                corrections += 1
        
        logger.info(f"‚úÖ CORRECTIONS APPLIQU√âES: {corrections}")
        still_missing = df_copy['Effectifs_Salesforce'].isna().sum()
        logger.info(f"   Effectifs encore manquants: {still_missing}")
        
        return df_copy
    
    def _get_mean_effectifs_by_taille(self, taille: str) -> Tuple[Optional[int], str]:
        """
        Retourne les effectifs moyens du config selon la taille d'entreprise
        Returns: (effectifs_numerique_moyen, confiance)
        """
        # Moyennes configur√©es dans config.yaml
        mapping = {
            'MICRO': (10, 'medium'),     # Milieu 0-19
            'PME': (135, 'medium'),      # Milieu 20-249 
            'ETI': (2625, 'medium'),     # Milieu 250-4999
            'GE': (10000, 'low')         # Estimation 5000+
        }
        
        return mapping.get(taille, (None, 'low'))
    
    def _log_salesforce_stats(self, df: pd.DataFrame):
        """Affiche les statistiques du fichier Salesforce g√©n√©r√©"""
        total_entreprises = len(df)
        avec_valeurs_numeriques = df['Effectifs_Salesforce'].notna().sum()
        
        # Distribution des statuts de r√©vision
        statuts_revision = df['Statut_Revision'].value_counts().to_dict()
        
        # Niveaux de confiance
        niveaux_confiance = df['Confiance_Donnee'].value_counts().to_dict()
        
        # Statistiques sur les effectifs
        effectifs_numeriques = df['Effectifs_Salesforce'].dropna()
        
        logger.info(f"\nüìà STATISTIQUES POUR SALESFORCE:")
        logger.info(f"   Total entreprises: {total_entreprises}")
        logger.info(f"")
        logger.info(f"üîç STATUTS DE R√âVISION:")
        for statut, count in statuts_revision.items():
            pourcentage = count / total_entreprises * 100
            logger.info(f"   {statut}: {count} ({pourcentage:.1f}%)")
        
        logger.info(f"\nüíº EFFECTIFS POUR SALESFORCE:")
        logger.info(f"   Avec valeurs num√©riques: {avec_valeurs_numeriques}/{total_entreprises} ({avec_valeurs_numeriques/total_entreprises*100:.1f}%)")
        if len(effectifs_numeriques) > 0:
            logger.info(f"   Moyenne: {effectifs_numeriques.mean():.0f} employ√©s")
            logger.info(f"   M√©diane: {effectifs_numeriques.median():.0f} employ√©s")
            logger.info(f"   Min-Max: {effectifs_numeriques.min():.0f} - {effectifs_numeriques.max():.0f}")
        
        logger.info(f"\nüéØ NIVEAUX DE CONFIANCE:")
        for niveau, count in niveaux_confiance.items():
            pourcentage = count / total_entreprises * 100
            logger.info(f"   {niveau}: {count} ({pourcentage:.1f}%)")